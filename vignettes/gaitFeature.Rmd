---
title: "gaitFeature"
author: "Kohleth Chia"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gaitFeature}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message=FALSE,
  warnings=FALSE
)
```

## Preeliminaries
This is an R package so I assume you are already familiar with R.

Throughout this guide we will be using the dataset `kinematics` which comes with this package.

## Installation

## Quick Start
The functions in this package assume the kinematics data is already loaded in R, in the **wide** format. Specifically, the kinematics `data.frame` should contain at least columns `curve_id`, `joint`, `plane`, `0,1,2,...,100`. Each row in the dataframe represent a kinematics curve on a particular joint and plane, identified by field `curve_id`, with data at 101 time points `0,1,2,...,100`.

The package ships with an example data `kinematics`.
```{r}
library(gaitFeature)
kinematics
```
```{r,include=FALSE}
library(dplyr) 
```
The simplest use is to run the `detectAll` function which runs all the off-the-shelf feature detectors on the supplied dataframe.
```{r}
detected=detectAll(kinematics)
detected%>%select(-(`0`:`100`))
```
Notice that packages `dplyr`, and `tidyr` are loaded by default when this package is loaded.

`detectAll` returns the same data.frame as what is supplied, with extra columns -- one for each feature. If the feature column is `NA`, it means that feature is not applicable to that curve (e.g. Ankle Internal Rotation (AIR) not relevant for the Pelvis curve.) If the field is `1` then that feature is detected, and `0` indicates the contrary.

The list of feature detectors that are called by `detectAll` is specified through the `fDict` argument. This argument should be a data.frame with column `fn` which list the names of the detectors to be called. Furthermore, it can have columns `joint` and `plane` which indicates which joint and plane a particular detector is related to. If `fDict=NULL` (default), it is generated on the spot by the `makeFDict` function.

```{r}
makeFDict()
```

If you are only interested at features that are a particular joint or plane, you can specify that in the `detectAll` call. But make sure the joint and plane value appears in the `fDict` data.frame.

```{r}
detectAll(kinematics, joint="Hip", plane="sag")%>%
  select(-(`0`:`100`))
```
Note that all of `kinematics` will still be returned. So the above result is different to 
```{r}
detectAll(kinematics%>%
            filter(joint=="Hip",plane=="sag"),joint="Hip",plane="sag")%>%
  select(-(`0`:`100`))
```

A (more) detailed explanation of why each feature is detected or not can be returned by setting `detectAll(...,comp=TRUE)` and inspecting the attributes.
```{r}
z=detectAll(kinematics,joint="Hip",plane="sag",comp=TRUE)
head(attr(z,"comp"),1)
```

`attr(.,"comp")` returns one dataframe for each feature. The columns that begin with `Cl:` indicates it is a clause (component) of the feature. All clauses must be `TRUE` for a feature to be detected.

You can also call the individual detector directly.
```{r}
.dtDecHipFxIC(kinematics)
```

## Constructing your own feature detector
Although the package ships with its own set of feature detectors. It is actually not that difficult to incorporate your own.
All the shipped feature detectors are functions whose name starts with `.dt`. See `?definitions`. 

### A naive example
In principle, feature detectors are just functions which take a data.frame and return another with columns `curve_id`, `Cl:xxx`, and `fname`, where `Cl:xxx` is the clause component of the feature definition, and `fname` is the machine-friendly feature name. So, for example,
```{r}
myRandomDetector=function(x){
  detected=sample(0:1,nrow(x),TRUE)
  data_frame(curve_id=x$curve_id,
             "Cl:random"=as.logical(detected),
             Random=detected)
}

myRandomDetector(kinematics)

```

And you can use the `detectAll` function with it.
```{r}
detectAll(kinematics,fDict=data.frame(fn="myRandomDetector"))%>%
  select(-(`0`:`100`))
```

If you want to use the `joint` and `plane` filter in `detectAll`, then you need to include those in the feature dictionary `fDict`.

```{r}
myRandomDetector2=function(x){
  x=filter(x,joint=="Knee",plane=="sag")
  myRandomDetector(x)
}
detectAll(kinematics,plane="sag",fDict=data_frame(joint="Knee",plane="sag",fn="myRandomDetector2"))%>%
  select(-(`0`:`100`))

## use a list of feature detectors.
oldfDict=makeFDict()%>%filter(joint=="Knee",plane=="sag")
fDict=rbind(oldfDict,
            data_frame(joint="Knee",
                       plane="sag",
                       fn="myRandomDetector2",
                       fname="Rnd",
                       featurename="Silly Random Feature"))
detectAll(kinematics,
          plane="sag",
          joint="Knee",
          fDict=fDict)%>%
  select(-(`0`:`100`))
```


### A realistic example

However, a useful feature detector will probably be more sophisticated than that. 
And this package provides some useful tool to construct these complicated features. 
But these tools assume a particular way of constructing feature detectors. 
In particular, a feature detector function should consist of 3 components:
1. A filter to a specific joint and plane.
2. One or more clauses.
3. A finish function.

#### 1. Filter
A feature should only apply to a particular joint and plane, so we recommend that you explicitly incorporate a filter in the definition.

#### 2. Clauses
A feature definition should consists of one or more *clauses*. 
The most commonly used clause is what we called a *univariate statistics clauses*.

And it works as followed:
1. From a curve select a time domain
2. Compute a summary statistics on the selected curve segment.
3. Compute the same statistics on each of the reference curve (for typically developed children)
4. If the statistics computed in 2. is extreme* compared to the set of statistics computed in 3., the clause is passed.

*The definition of extreme is user-definable. For example, it can be > mean + 2 standard deviation.

This clause is implemented in the function `unistat`. See `?unistat`.
For example ``unistat(x,`60`:`100`, .f=mean, .dir=">", .k=2)`` reads the mean angle at t%in%[60,100] should be greater than mean + 2SD of the same mean copmuted from the typical reference data.

`.f` can be any function which returns a single number statistics. See `?.tp` for commonly used functions that ships with this package.

The possible directions `.dir` are: `>(=)`, `<(=)`, `%w%`, and `%o%`, where the last two stands for 'within' and 'outside'.

An absolute threshold can be specified by using the `.c=xxx` argument instead of `.k=xx`. 


#### 3. Finish with `finish`
A feature detector function should finish off with the `finish` function, which does several house-keeping functions, such as checking all clauses are passed before the feature is deemed present, and setting various attributes appropriately.


#### Example
If we look at the detector for increased ankle rotation.
```{r}
.dtAIR
```

We will see that,

1. it is a feature which applies to the Ankle on the transverse plane.
2. There is one clause, which reads the mean angle at t%in%[60,100] should be greater than mean + 2SD (default) of the same mean copmuted from the typical reference data.
3. The machine-friendly name for this feature is 'AIR', and the human interpretable name is 'Ankle Internal Rotation'.

### Multiple clauses
Multiple clauses can be chained together by the pipe `%>%` operator.
For example,
```{r}
.dtDecPelTiltIncROM
```
has 2 clauses.

### Other clauses
In addition to `unistat`, we provide two more clause functions: `corr` and `custom`.
These clauses become useful when the feature is difficult to define through `unistat`.


#### Correlation clause `corr`
A correlation clause works as follow:

1. From a curve select a time domain.
2. Correlate that curve segment with a set of pre-supplied target curves.
3. If any of the correlation meets the target threshold the clause is passed

Therefore, in order to use this clause, a set of target curves needs to be supplied (using the `corr(..., TC=x,...)`).

This package ships with 5 sets of target curves, which can be assessed by the `.tc()` function.
They are: `.tc()$ett`, `.tc()$uni`, `.tc()$s2r`, `.tc()$revrom`, and `.tc()$dblbump`, which are target curves for
'External Tibial Torsion', 'Uni Bump', 'Short 2nd rocker', 'Reverse ROM', and 'Double Bump'.

Since all these curves have domain 0:100, the same domain should be specified in the `corr` function.

Straightly speaking, we could use the `unistat` clause to achieve the same result. That is,

`corr(...,TC=x,">=",0.8)` is equivalent to

``unistat(`0`:`100`,.f=function(x)max(apply(t(.tc()$dblbump),2,cor,x)),.dir=">=",.c=0.8)``

(the `apply` function is only needed because we have a set of `TC`. Otherwise a simple `cor` will suffice.)

However, the `corr` clause is just more literal and thus easier to interpret.

#### Custom clause `custom`
The custom clause function `custom` allows one to supply a custom condition through as a string `custom(...,cond)`.
It is particularly useful for clauses that require data other than the kinematics, such as timing related clauses. For example,
```{r}
.dtDelayPkKnFx
```
has a clause which says the peak angle after `t=60` must occur after `t=75`.

Again, straightly speaking, this clause can be expressed as a univariate clause. That is,

``custom(`60`:`100`, cond="t[which.max(angle)]>75")`` 

is equivalent to 

``unistat(`60`:`100`,.f=function(x)which.max(x),.dir=">",.c=75-60+1)``.
 
However, the `unistat` version relies on the assumption that `x` in `.f` is sorted inn `t`, whereas `custom` is explicitly extracting `t`.

## Resampling
All functions in this package assume the kinematics curves are sampled at 101 time points.
If this is not the case, there is a sampling function `?resamp101` which fits a periodic cubic spline to your existing curves, and then resample the 101 times points from it.

```{r}
## x is a coarser version of kinematics
x=kinematics%>%
  select(curve_id,`0`,`10`,`20`,`30`,`40`,`50`,`60`,`70`,`80`,`90`,`100`)

y=resamp101(x,`0`:`100`,plot=T)
```

The `plot=T` argument plots the interpolated lines together with the observed points. 
It is recommended that you leave it as `FALSE` (default) if you are resampling many curves, because the plot will just be cluttered.
