% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clauses.R
\name{unistat}
\alias{unistat}
\alias{corr}
\alias{custom}
\alias{finish}
\title{Feature clauses}
\usage{
unistat(x, ..., .f, .dir, .c, k = 1, clDesc = NULL)

corr(x, ..., TC, .dir = ">=", .c = 0.8, clDesc = NULL)

custom(x, ..., cond, clDesc)

finish(x, featurename, fname)
}
\arguments{
\item{x}{dataframe of gait kinematics values. Must have columns curve_id, 0, 1, ..., 100}

\item{...}{the columns of x which \code{.f} should apply to. It should really be the time domain. E.g. `60`:`100` (including the back tick).}

\item{.f}{a function to summarize the kinematics. See}

\item{.dir}{a single string. Either \code{>(=)},\code{<(=)},\code{\%o\%}, or \code{\%w\%}. This represents the comparative direction of the clause. The last two values represent 'outside' and 'within' respectively.}

\item{.c}{numeric. The comparative threshold. See \code{Details}.}

\item{k}{numeric, the number of standard deviation used to form the comparative threshold. Ignored if \code{.c} is specified.}

\item{clDesc}{a character string which describes this clause. It must begin with "Cl:" which stands for 'Clause:'. If \code{NULL} (default) it is automatically constructed as \code{Cl:f(...).dir.c}}

\item{TC}{a matrix of typical feature curves. Each row represent each curve, and the columns must be 0,1,...,100. See \code{Details}.}

\item{cond}{a custom condition statement. See \code{Details}.}

\item{featurename}{Character string. The human readable name of the feature.}

\item{fname}{Character string. A machine friendly version of featurename. It is recommended that you do not use any special character in this field.}
}
\value{
the same as \code{x} but with an added column which indicate whether the row passes the criterion, and an inherited class as specified by the \code{class} argument.
}
\description{
Convenient functions to integrate a clause into a feature definition.
}
\details{
A feature consists of n>=1 clause(s). Each clause usually works by comparing some statistics between the curve under consideration and a reference set.
Specifically, each clause works as followed:
\enumerate{
  \item Select the kinematics at the relevant time points as specified by \code{...}, call this \code{x[...]}.
  \item Apply \code{.f} to \code{x[...]} and the reference curve.
  \item If \code{.c} is not specified, compute it. (e.g. mean(reference curve stats)+\code{k}standard deviation).
  \item If \code{.f(x[...]) .dir .c}, then it passess the clauses, thus raising a positive flag.
}

The \code{unistat} function stands for univariate statistics clause. This should be the most frequently used clause.

The \code{corr} function  stands for correlation clause. A set of target curve, \code{TC}, with which the curve under consideration will be correlated against, needs to be provided.
The \code{.c} in this context becomes the correlation threshold so it should be between -1 and 1.

The \code{custom} function allows user to specify other clauses that could not be (easily) specified by either \code{unistat} or \code{corr}.
This is useful for timing clause. e.g. \code{custom(`60`:`100`,cond="t[which.max(angle)]>75")}.

If these convenience functions are used, then the result should always be passed to the \code{finish} function which formats the output properly.
For example, if a feature consist of multiple clauses, the \code{finish} function will check that each clauses are passed (i.e. positive) in order to classify the feature as being detected.
}
\section{Functions}{
\itemize{
\item \code{corr}: correlation clause

\item \code{custom}: custom clause

\item \code{finish}: finish
}}

\examples{
library(dplyr)
.dtEPS=function(df){
  df\%>\%
  filter(joint=="FootProgress"&plane=="tra")\%>\%
  unistat(`60`:`100`,.f=.ROM,.dir=">",k=2)\%>\%
  corr(`0`:`100`,TC=.tc()$ett)\%>\%
  finish(featurename = "External Foot Progression (Wave) in Swing only.",fname = "EPS")
}

.dtEPS(kinematics)

}
